"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ajv_1 = __importDefault(require("ajv"));
const bytes_1 = __importDefault(require("bytes"));
const manifest_schema_json_1 = __importDefault(require("../manifest-schema.json"));
const validate_https_url_1 = __importDefault(require("./validate-https-url"));
/**
 * @param {Object} json
 * @param {Object=} options
 * @return {{valid: boolean, errors: Array<!Object>}} errors is null if valid
 */
exports.default = (json, options = {}) => {
    let relativePath = (...args) => true;
    let maxFileSize = (...args) => true;
    if (typeof options.relativePath === "function") {
        relativePath = options.relativePath;
    }
    if (typeof options.maxFileSize === "function") {
        maxFileSize = options.maxFileSize;
    }
    const ajv = new ajv_1.default({
        allErrors: true,
        formats: {
            "http-url": (str) => (0, validate_https_url_1.default)(str, true),
            "https-url": (str) => (0, validate_https_url_1.default)(str),
            "relative-path": relativePath,
        },
    });
    const validateMaxFileSize = (schema, data) => {
        // schema: max file size like "512KB" or 123 (in bytes)
        // data: path to the file
        const maxBytes = bytes_1.default.parse(schema);
        const valid = maxFileSize(maxBytes, data);
        if (!valid) {
            validateMaxFileSize.errors = [
                {
                    keyword: "maxFileSize",
                    params: {
                        limit: maxBytes,
                    },
                    message: `file size should be <= ${schema}`,
                },
            ];
        }
        return valid;
    };
    ajv.addKeyword({
        keyword: "maxFileSize",
        validate: validateMaxFileSize,
    });
    const validate = ajv.compile(manifest_schema_json_1.default);
    const valid = validate(json);
    return { valid, errors: transformErrors(validate.errors) };
};
/**
 * @param {undefined|null|Array<Object>} errors
 * @return {null|Array<Object>} shallow copy of the input or null
 */
const transformErrors = (errors) => {
    if (!errors) {
        return null;
    }
    // shallow copy
    return errors.slice();
};
//# sourceMappingURL=index.js.map