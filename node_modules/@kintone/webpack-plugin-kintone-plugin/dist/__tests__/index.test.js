"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const rimraf_1 = __importDefault(require("rimraf"));
const webpack_1 = __importDefault(require("webpack"));
const util_1 = require("util");
const helpers_1 = require("./helpers");
const webpack_merge_1 = __importDefault(require("webpack-merge"));
const index_1 = __importDefault(require("../index"));
const pluginDir = path_1.default.resolve(__dirname, "fixtures", "sample");
const pluginJsOutputPaths = [
    path_1.default.resolve(pluginDir, "plugin", "js", "desktop.js"),
    path_1.default.resolve(pluginDir, "plugin", "js", "mobile.js"),
    path_1.default.resolve(pluginDir, "plugin", "js", "config.js"),
];
const PLUGIN_ID = "nfjiheanbocphdnoehhpddjmkhciokjb";
const tempDir = fs_1.default.mkdtempSync(path_1.default.join(os_1.default.tmpdir(), "kintone-webpack-plugin-kintone-plugin-index-"));
const webpackBaseConfig = {
    mode: "production",
    entry: {
        desktop: path_1.default.resolve(pluginDir, "src", "desktop.js"),
        mobile: path_1.default.resolve(pluginDir, "src", "mobile.js"),
        config: path_1.default.resolve(pluginDir, "src", "config.js"),
    },
    output: {
        path: path_1.default.resolve(pluginDir, "plugin", "js"),
        filename: "[name].js",
    },
};
describe("KintonePlugin", () => {
    afterAll(() => {
        rimraf_1.default.sync(tempDir);
    });
    afterEach(() => {
        [...pluginJsOutputPaths].forEach((generatedFilePath) => {
            try {
                fs_1.default.unlinkSync(generatedFilePath);
            }
            catch (e) {
                // noop
            }
        });
    });
    it("should be able to create a plugin zip", () => __awaiter(void 0, void 0, void 0, function* () {
        const pluginZipPath = path_1.default.resolve(tempDir, "plugin.zip");
        const config = (0, webpack_merge_1.default)(webpackBaseConfig, {
            plugins: [
                new index_1.default({
                    manifestJSONPath: path_1.default.resolve(pluginDir, "plugin", "manifest.json"),
                    privateKeyPath: path_1.default.resolve(pluginDir, "private.ppk"),
                    pluginZipPath,
                }),
            ],
        });
        const compiler = (0, webpack_1.default)(config);
        yield (0, util_1.promisify)(compiler.run).bind(compiler)();
        (0, helpers_1.verifyPluginZip)(pluginZipPath);
        yield (0, util_1.promisify)(compiler.close).bind(compiler)();
    }));
    it("should be able to customize the zip name", () => __awaiter(void 0, void 0, void 0, function* () {
        const pluginZipPath = path_1.default.resolve(tempDir, `${PLUGIN_ID}.sample.plugin.zip`);
        const config = (0, webpack_merge_1.default)(webpackBaseConfig, {
            plugins: [
                new index_1.default({
                    manifestJSONPath: path_1.default.resolve(pluginDir, "plugin", "manifest.json"),
                    privateKeyPath: path_1.default.resolve(pluginDir, "private.ppk"),
                    pluginZipPath: (id, manifest) => path_1.default.resolve(tempDir, `${id}.${manifest.name.en.replace(/\s/g, ".")}.zip`),
                }),
            ],
        });
        const compiler = (0, webpack_1.default)(config);
        yield (0, util_1.promisify)(compiler.run).bind(compiler)();
        (0, helpers_1.verifyPluginZip)(pluginZipPath);
        yield (0, util_1.promisify)(compiler.close).bind(compiler)();
    }));
    it("should be able to create the zip directory if it does not exist", () => __awaiter(void 0, void 0, void 0, function* () {
        const pluginZipPath = path_1.default.resolve(tempDir, "nonExistDir", "plugin.zip");
        const config = (0, webpack_merge_1.default)(webpackBaseConfig, {
            plugins: [
                new index_1.default({
                    manifestJSONPath: path_1.default.resolve(pluginDir, "plugin", "manifest.json"),
                    privateKeyPath: path_1.default.resolve(pluginDir, "private.ppk"),
                    pluginZipPath,
                }),
            ],
        });
        const compiler = (0, webpack_1.default)(config);
        yield (0, util_1.promisify)(compiler.run).bind(compiler)();
        (0, helpers_1.verifyPluginZip)(pluginZipPath);
        yield (0, util_1.promisify)(compiler.close).bind(compiler)();
    }));
    it("should be able to create the zip directory if it does not exist and using customize the zip name", () => __awaiter(void 0, void 0, void 0, function* () {
        const pluginZipPath = path_1.default.resolve(tempDir, "nonExistDirWithCustomizeName", `${PLUGIN_ID}.sample.plugin.zip`);
        const config = (0, webpack_merge_1.default)(webpackBaseConfig, {
            plugins: [
                new index_1.default({
                    manifestJSONPath: path_1.default.resolve(pluginDir, "plugin", "manifest.json"),
                    privateKeyPath: path_1.default.resolve(pluginDir, "private.ppk"),
                    pluginZipPath: (id, manifest) => path_1.default.resolve(tempDir, "nonExistDirWithCustomizeName", `${id}.${manifest.name.en.replace(/\s/g, ".")}.zip`),
                }),
            ],
        });
        const compiler = (0, webpack_1.default)(config);
        yield (0, util_1.promisify)(compiler.run).bind(compiler)();
        (0, helpers_1.verifyPluginZip)(pluginZipPath);
        yield (0, util_1.promisify)(compiler.close).bind(compiler)();
    }));
});
//# sourceMappingURL=index.test.js.map