"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const path_1 = __importDefault(require("path"));
const plugin_1 = require("./plugin");
class KintonePlugin {
    constructor(options = {}) {
        this.name = "KintonePlugin";
        this.privateKey = null;
        this.options = Object.assign({
            manifestJSONPath: "./plugin/manifest.json",
            privateKeyPath: "./private.ppk",
            pluginZipPath: "./dist/plugin.zip",
        }, options);
    }
    apply(compiler) {
        const { manifestJSONPath, privateKeyPath } = this.options;
        compiler.hooks.afterPlugins.tap(this.name, () => {
            if (!fs_1.default.existsSync(manifestJSONPath)) {
                throw new Error(`manifestJSONPath cannot found: ${manifestJSONPath}`);
            }
            if (!fs_1.default.existsSync(privateKeyPath)) {
                throw new Error(`privateKeyPath cannot found: ${privateKeyPath}`);
            }
            this.privateKey = fs_1.default.readFileSync(privateKeyPath, "utf-8");
            if (compiler.options.watch || compiler.watchMode) {
                compiler.hooks.afterCompile.tap(this.name, (compilation) => {
                    // Watch assets specified in manifest.json
                    // https://webpack.js.org/contribute/plugin-patterns/#monitoring-the-watch-graph
                    const allAssetPaths = (0, plugin_1.getAssetPaths)(this.options.manifestJSONPath);
                    const chunkPaths = [...compilation.chunks]
                        .reduce((paths, chunk) => paths.concat([...chunk.files]), [])
                        .map((chunkFile) => path_1.default.resolve(compiler.outputPath, chunkFile));
                    // exclude output chunks because afterEmit is triggered twice when js source file changed.
                    const assetPaths = allAssetPaths.filter((assetPath) => !chunkPaths.includes(assetPath));
                    compilation.fileDependencies.addAll(assetPaths);
                });
            }
            compiler.hooks.afterEmit.tapPromise(this.name, () => this.generatePlugin());
        });
    }
    /**
     * Generate a plugin zip
     */
    generatePlugin() {
        const { manifestJSONPath, pluginZipPath } = this.options;
        return (0, plugin_1.generatePlugin)(manifestJSONPath, this.privateKey).then((result) => {
            const zipPath = 
            // You can customize the zip file name using the plugin id and manifest
            typeof pluginZipPath === "function"
                ? pluginZipPath(result.id, JSON.parse(fs_1.default.readFileSync(manifestJSONPath, "utf-8")))
                : pluginZipPath;
            const zipDir = path_1.default.dirname(zipPath);
            if (!fs_1.default.existsSync(zipDir)) {
                mkdirp_1.default.sync(zipDir);
            }
            fs_1.default.writeFileSync(zipPath, result.buffer);
            console.log("----------------------");
            console.log("Success to create a plugin zip!");
            console.log(`Plugin ID: ${result.id}`);
            console.log(`Path: ${zipPath}`);
            console.log("----------------------");
        });
    }
}
exports.default = KintonePlugin;
module.exports = KintonePlugin;
module.exports.default = module.exports;
//# sourceMappingURL=index.js.map